# ------------------------------------------------------------------------------------------------------------
# NOTE: THIS FILE IS AUTO GENERATED AND MANAGED BY https://github.com/zendesk/cicd-toolkit
#
# You can regenerate the content by running `make` in the 'cicd-toolkit' directory.
#
# MANUAL CHANGES TO THIS FILE MAY RESULT IN INCORRECT BEHAVIOUR, AND WILL BE LOST IF THE CODE IS REGENERATED.
# ------------------------------------------------------------------------------------------------------------
name: Create deployment artifacts for branch

on:
  workflow_dispatch:
    inputs:
      tag:
        description: 'Tag to create deployment artifacts for, defaults to the same as commit the workflow is run from.'
        required: false
  pull_request:
    types: [opened, reopened, synchronize, labeled]
  issue_comment:
    types: [created]

env:
  AWS_PROFILE: "ecr-publish"
  DOCKER_IMAGE: "713408432298.dkr.ecr.us-west-2.amazonaws.com/dev/zendesk/ml-training-pipelines"
  ECR_IMAGE_PREFIX: "dev"

jobs:
  generate:
    name: build-artifacts
    runs-on: ["self-hosted", "zendesk-stable"]
    if:
      (github.event.action == 'labeled' && github.event.label.name == 'update manifests') ||
        (github.event.action != 'labeled' && contains(github.event.pull_request.labels.*.name, 'update manifests')) ||
        startsWith(github.event.comment.body, '/update manifests') || github.event_name == 'workflow_dispatch'
    steps:

      - name: Checkout
        uses: zendesk/checkout@v3

# cicd-toolkit preamble begin
      - name: bootstrap cicd-toolkit
        env:
          APPCONFIG_DOCKER_IMAGE: 713408432298.dkr.ecr.us-west-2.amazonaws.com/zendesk/appconfig:v1.5.0
        run: |
          cid=$(docker create "$APPCONFIG_DOCKER_IMAGE")
          sudo docker cp $cid:/bin/appconfig /usr/local/bin

          echo >&2 "appconfig version"
          echo >&2 "==="
          appconfig version
          echo >&2 "==="

          echo >&2 "vendir version"
          echo >&2 "==="
          vendir version
          echo >&2 "==="

          echo >&2 "kbld version"
          echo >&2 "==="
          kbld version
          echo >&2 "==="

      - name: cache vendor dependencies
        uses: zendesk/cache@v3
        id: cicd-cache-vendor
        with:
          path: cicd-toolkit/vendor
          key: ${{ runner.os }}-${{ hashFiles('cicd-toolkit/vendir.lock.yml') }}

      - name: install dependencies
        if: steps.cicd-cache-vendor.cache-hit != 'true'
        env:
          APPLICATION_ROOT_DIR: "cicd-toolkit"
        run: |
          ORG_BASIC_AUTH="$(echo -n 'x-access-token:${{ secrets.ORG_GITHUB_TOKEN }}' | base64)"
          echo "::add-mask::$ORG_BASIC_AUTH"
          env \
            GIT_CONFIG_COUNT=2 \
            GIT_CONFIG_KEY_0='http.https://github.com/.extraheader' \
            GIT_CONFIG_VALUE_0='' \
            GIT_CONFIG_KEY_1='http.https://github.com/.extraheader' \
            GIT_CONFIG_VALUE_1="Authorization: basic $ORG_BASIC_AUTH" \
            vendir sync --chdir "$APPLICATION_ROOT_DIR" --locked

          echo >&2 "Checking for differences in vendored dependencies lock file ..."

          if ! git diff --exit-code "$APPLICATION_ROOT_DIR/vendir.lock.yml"; then
            echo >&2 "==="
            echo >&2 "Notice: Found above differences in vendir.lock.yml file..."
            echo >&2 "==="
          else
            echo >&2 "No differences found."
          fi

      - name: extract actions if not present
        env:
          APPLICATION_ROOT_DIR: "cicd-toolkit"
        run: |
          # extract actions unless present already
          if [ ! -d "$APPLICATION_ROOT_DIR/actions" ]; then
            (cd $APPLICATION_ROOT_DIR && \
              appconfig run boilerplate:github-actions) | \
                appconfig manifest --state-file /dev/null
          fi

# cicd-toolkit preamble end


      - name: setup env vars from project metadata
        uses: ./cicd-toolkit/actions/env-vars-from-project-metadata
        with:
          application_root_dir: "cicd-toolkit"

      - name: Rocket reaction reply
        uses: zendesk/github-script@v6.3.3
        if: github.event_name == 'issue_comment' && github.event.issue.pull_request
        id: issue_comment_pr
        with:
          script: |
            const { data: pr } = await github.request(context.payload.issue.pull_request.url)
            if (pr) {
              core.setOutput('head_ref', pr.head.ref)
              core.setOutput('head_sha', pr.head.sha)
              core.setOutput('base_ref', pr.base.ref)
              core.setOutput('base_sha', pr.base.sha)

              github.rest.reactions.createForIssueComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: context.payload.comment.id,
                content: 'rocket',
              })
            }

      - name: Normalize references
        uses: ./cicd-toolkit/actions/normalize-refs
        id: normalize_refs
        with:
          tag: ${{ steps.issue_comment_pr.outputs.head_ref }}
          sha: ${{ steps.issue_comment_pr.outputs.head_sha }}

      - name: Detect release type
        id: release_type
        uses: ./cicd-toolkit/actions/detect-release-type
        with:
          application_root_dir: ${{ env.APPLICATION_ROOT_DIR }}
          github_token: ${{ secrets.GITHUB_TOKEN }}
          base_ref: ${{ steps.issue_comment_pr.outputs.base_ref || github.base_ref }}
          head_ref: ${{ steps.issue_comment_pr.outputs.head_ref || github.head_ref }}
          release_version_type: ${{ env.RELEASE_VERSION_TYPE }}
          release_version_type_for_config_only: ${{ env.RELEASE_VERSION_TYPE_FOR_CONFIG_ONLY }}

      - name: Detect hotfix revision
        id: detect_hotfix
        uses: ./cicd-toolkit/actions/detect-hotfix
        with:
          application_root_dir: ${{ env.APPLICATION_ROOT_DIR }}
          hotfix_tag: ${{ github.event.inputs.tag }}
          base_ref: ${{ steps.issue_comment_pr.outputs.base_ref || github.base_ref }}
          docker_image: ${{ env.DOCKER_IMAGE }}
          github_token: ${{ secrets.GITHUB_TOKEN }}
          hotfix_ref_type: 'branch'
          hotfix_config_only: ${{ steps.release_type.outputs.config-only }}
          hotfix_detection_enabled: ${{ steps.release_type.outputs.release-hotfix-detection-enabled }}

      - name: Add cicd-toolkit-hotfix label
        if: github.event_name != 'workflow_dispatch' && steps.detect_hotfix.outputs.hotfix_enabled == 'true'
        uses: zendesk/github-script@v6.3.3
        with:
          github-token: ${{secrets.GITHUB_TOKEN}}
          script: |
            github.rest.issues.addLabels({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: ['cicd-toolkit-hotfix']
            })

      - name: Remove cicd-toolkit-hotfix label
        if: github.event_name != 'workflow_dispatch' && steps.detect_hotfix.outputs.hotfix_enabled == 'false' && contains(github.event.pull_request.labels.*.name, 'cicd-toolkit-hotfix')
        uses: zendesk/github-script@v6.3.3
        with:
          github-token: ${{secrets.GITHUB_TOKEN}}
          script: |
            github.rest.issues.removeLabel({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              name: 'cicd-toolkit-hotfix'
            })

      - name: Setup deploy branch
        uses: ./cicd-toolkit/actions/setup-deploy-branch
        id: setup-deploy-branch
        with:
          deploy_ref: ${{ steps.normalize_refs.outputs.deploy_ref }}
          sha: ${{ steps.normalize_refs.outputs.sha }}

      - name: Generate deploy config
        if: env.DEPLOYMENT_CONFIG_TRACKING_ENABLED == 'true'
        uses: ./cicd-toolkit/actions/generate-deploy-cfg
        id: generate-deploy-cfg
        with:
          working_directory: ${{ env.APPLICATION_ROOT_DIR }}
          output_directory: ${{ env.DEPLOY_CFG_OUTPUT_DIR }}/kubernetes/deploy
          base_deploy_ref: ${{ steps.detect_hotfix.outputs.base_deploy_ref }}
          base_deploy_sha: ${{ steps.detect_hotfix.outputs.base_deploy_sha }}
          deploy_ref: ${{ steps.normalize_refs.outputs.deploy_ref }}

      - name: Generate deployment manifests
        uses: ./cicd-toolkit/actions/generate-manifests
        with:
          deployment_branch: ${{ steps.normalize_refs.outputs.ref }}
          deployment_revision: ${{ steps.normalize_refs.outputs.sha }}
          deployment_tag: ${{ steps.normalize_refs.outputs.ref }}
          deployment_version: ${{ steps.normalize_refs.outputs.ref }}-${{ steps.normalize_refs.outputs.sha }}
          docker_image: ${{ env.DOCKER_IMAGE }}
          ecr_image_prefix: ${{ env.ECR_IMAGE_PREFIX }}
          docker_image_tag: ${{ steps.detect_hotfix.outputs.hotfix_image_tag || steps.normalize_refs.outputs.sha }}
          working_directory: ${{ env.APPLICATION_ROOT_DIR }}
          output_directory: ${{ env.DEPLOY_CFG_OUTPUT_DIR }}/kubernetes/manifests


      - name: Commit manifests (unresolved)
        id: commit_manifests_unresolved
        uses: ./cicd-toolkit/actions/commit-manifests
        with:
          deploy_branch: ${{ steps.normalize_refs.outputs.deploy_ref }}
          output_directory: ${{ env.DEPLOY_CFG_OUTPUT_DIR }}/kubernetes

      - name: Wait for image build(s)
        if: steps.detect_hotfix.outputs.hotfix_enabled == 'false'
        uses: ./cicd-toolkit/actions/wait-for-images
        timeout-minutes: 30
        with:
          tag: ${{ steps.normalize_refs.outputs.sha }}
          working_directory: ${{ env.APPLICATION_ROOT_DIR }}
          ecr_image_prefix: ${{ env.ECR_IMAGE_PREFIX }}

      - name: Resolve container images in manifests
        uses: ./cicd-toolkit/actions/resolve-images
        with:
          output_directory: ${{ env.DEPLOY_CFG_OUTPUT_DIR }}/kubernetes
          manifests_directory: ${{ env.DEPLOY_CFG_OUTPUT_DIR }}/kubernetes/manifests
          working_directory: ${{ env.APPLICATION_ROOT_DIR }}
          hotfix_image_lock_file: ${{ steps.detect_hotfix.outputs.hotfix_image_lock_file }}
          deployment_revision: ${{ steps.normalize_refs.outputs.sha }}

      - name: Write artifacts ready marker
        uses: ./cicd-toolkit/actions/write-artifacts-ready
        with:
          git_commit: ${{ steps.normalize_refs.outputs.sha }}
          git_ref: ${{ steps.normalize_refs.outputs.ref }}
          output_directory: ${{ env.DEPLOY_CFG_OUTPUT_DIR }}/kubernetes/deploy

      - name: Commit manifests (resolved)
        id: commit_manifests_resolved
        uses: ./cicd-toolkit/actions/commit-manifests
        with:
          message: Resolved manifests for ${{ steps.normalize_refs.outputs.sha }}
          deploy_branch: ${{ steps.normalize_refs.outputs.deploy_ref }}
          output_directory: ${{ env.DEPLOY_CFG_OUTPUT_DIR }}/kubernetes
          force: "true"
          push: "true"

      - name: Post deployment config is ready comment
        uses: zendesk/github-script@v6.3.3
        if: env.PULL_REQUEST_COMMENT_UPDATES_ENABLED == 'true' && github.event_name != 'workflow_dispatch'
        env:
          HOTFIX_SHA: ${{ steps.detect_hotfix.outputs.hotfix_sha }}
          HOTFIX_TAG: ${{ steps.detect_hotfix.outputs.hotfix_tag }}
          HOTFIX_RELEASE_TAG: ${{ steps.detect_hotfix.outputs.hotfix_release_tag }}
          HOTFIX_DIGEST: ${{ steps.detect_hotfix.outputs.hotfix_digest }}
          HOTFIX_IMAGE_TAG: ${{ steps.detect_hotfix.outputs.hotfix_image_tag }}
          HOTFIX_ENABLED: ${{ steps.detect_hotfix.outputs.hotfix_enabled }}
          HOTFIX_FROM_COMMIT_SHA: ${{ steps.release_type.outputs.release-hotfix-from-commit }}
          CONFIG_SHA: ${{ steps.normalize_refs.outputs.sha }}
          CONFIG_REF: ${{ steps.normalize_refs.outputs.ref }}
          DEPLOY_SHA: ${{ steps.commit_manifests_resolved.outputs.deploy_commit }}
          DEPLOY_REF: ${{ steps.commit_manifests_resolved.outputs.deploy_branch }}
          HAS_ENV_VARS_CHANGES: ${{ steps.generate-deploy-cfg.outputs.has-env-vars-changes }}
          HAS_ROLE_SCALING_CHANGES: ${{ steps.generate-deploy-cfg.outputs.has-role-scaling-changes }}
          HAS_SECRETS_CHANGES: ${{ steps.generate-deploy-cfg.outputs.has-secrets-changes }}
        with:
          github-token: ${{secrets.GITHUB_TOKEN}}
          script: |
            const CICD_TOOLKIT_COMMENT_MARKER = '<!-- [CICD_TOOLKIT_PR_COMMENT] -->';

            let executionURL = '${{ env.SPINNAKER_WEB_ENDPOINT }}/#/applications/${{ env.PROJECT_NAME }}/executions/?startManualExecution=${{ env.SPINNAKER_STAGES_BRANCH }}&gitRef=${{ env.CONFIG_REF }}'

            let image_tag = '[${{ env.CONFIG_SHA }}](https://${{ env.DOCKER_IMAGE }}:${{ env.CONFIG_SHA }})'
            if ('HOTFIX_IMAGE_TAG' in process.env && process.env.HOTFIX_IMAGE_TAG != '' && 'HOTFIX_ENABLED' in process.env && process.env.HOTFIX_ENABLED == 'true') {
              image_tag = '[${{ env.HOTFIX_IMAGE_TAG }}](https://${{ env.DOCKER_IMAGE }}:${{ env.HOTFIX_IMAGE_TAG }})'
            }

            function hasChanges(key, url) {
              return (key in process.env && process.env[key] == 'true') ? '[Compare :warning:](' + url + ')' : '[_No changes_](' + url + ')'
            }

            let repoBase = 'https://github.com/${{ github.repository }}'
            let compareBase = repoBase + '/compare'
            let treeBase = repoBase + '/tree/${{ env.DEPLOY_REF }}'
            let blobBase = repoBase + '/blob/${{ env.DEPLOY_REF }}'
            let kubernetesBase = treeBase + '/kubernetes'
            let docsBase = kubernetesBase + '/deploy/docs'

            let detailsBody = [
              '| Type | Value |',
              '| - | - |',
              '| Commit | ${{ env.CONFIG_SHA }} |',
              '| Image Tag | ' + image_tag + '|',
              '| Deploy branch | [${{ env.DEPLOY_REF}}](' + treeBase + ') @ ${{ env.DEPLOY_SHA }} |',
              '| Spinnaker deploy URL | ' + executionURL + '|',
            ]

            if ('SPINNAKER_STAGES_BRANCH' in process.env && process.env.SPINNAKER_STAGES_BRANCH != '') {
              let deployCompanionStage = process.env.SPINNAKER_STAGES_BRANCH.replace(/-lockable$/, '')
              detailsBody.push('| Deploy companion URL | https://deploy-companion.zende.sk/projects/${{ env.PROJECT_NAME }}/deploys/' + deployCompanionStage + '?repo=${{ env.PROJECT_NAME }} |')
            }

            if ('DEPLOYMENT_CONFIG_TRACKING_ENABLED' in process.env && process.env.DEPLOYMENT_CONFIG_TRACKING_ENABLED == 'true') {

              let compareTrackingBody = [
                '',
                'This release contains changes to the following configuration areas',
                '',
                '| Config type | Inspect changes |',
                '| - | - |',
                '| [Environment variables](' + docsBase + '/env-vars.csv) | ' + hasChanges('HAS_ENV_VARS_CHANGES', compareBase + '/${{ env.DEPLOY_REF }}~5..${{ env.DEPLOY_REF }}~4') + '|',
                '| [Role scaling](' + docsBase + '/role-scaling.csv) | ' + hasChanges('HAS_ROLE_SCALING_CHANGES', compareBase + '/${{ env.DEPLOY_REF }}~4..${{ env.DEPLOY_REF }}~3') + '|',
                '| [Secrets](' + docsBase + '/secrets.csv) | ' + hasChanges('HAS_SECRETS_CHANGES', compareBase + '/${{ env.DEPLOY_REF }}~3..${{ env.DEPLOY_REF }}~2') + '|',
              ]

              detailsBody = detailsBody.concat(compareTrackingBody)
            }

            if ('HOTFIX_TAG' in process.env && process.env.HOTFIX_TAG != '') {

              if ('HOTFIX_ENABLED' in process.env && process.env.HOTFIX_ENABLED == 'true') {
                hotfixDetailsBody = [
                  '',
                  'This release is a hotfix that only contains configuration changes with application image picked up from',
                  '',
                  '| Type | Value |',
                  '| - | - |',
                  '| Ref | `${{ env.HOTFIX_TAG }}` @ ${{ env.HOTFIX_SHA }} |',
                  '| Digest | [${{ env.HOTFIX_DIGEST }}](https://${{ env.DOCKER_IMAGE }}@${{ env.HOTFIX_DIGEST }}) |',
                  '| Image tag | ${{ env.HOTFIX_IMAGE_TAG }} |',
                  '| Release tag | ${{ env.HOTFIX_RELEASE_TAG }} |',
                ]
              } else {
                hotfixDetailsBody = [
                  '',
                  'This release compares changes from',
                  '',
                  '| Type | Value |',
                  '| - | - |',
                  '| Ref | `${{ env.HOTFIX_TAG }}` @ ${{ env.HOTFIX_SHA }} |',
                  '| Release tag | [${{ env.HOTFIX_RELEASE_TAG }}](' + repoBase + '/releases/${{ env.HOTFIX_RELEASE_TAG }}' + ') |',
                ]
              }

              detailsBody = detailsBody.concat(hotfixDetailsBody)
            }

            if ('HOTFIX_FROM_COMMIT_SHA' in process.env && process.env.HOTFIX_FROM_COMMIT_SHA != '') {
              hotfixDetailsBody = [
                '',
                'This release has *disabled* hotfixes based on annotation on ${{ env.HOTFIX_FROM_COMMIT_SHA }}',
              ]

              detailsBody = detailsBody.concat(hotfixDetailsBody)
            }

            let detailsMsg = detailsBody.join("\n")

            let body = []

            body.push(CICD_TOOLKIT_COMMENT_MARKER)
            const meetAndGreetMessage = `This PR can be deployed with [cicd-toolkit](https://github.com/zendesk/cicd-toolkit): Generate deployment config by commenting \`/update manifests\` on this PR for one time generation.`
            body.push(meetAndGreetMessage)
            body.push('')
            body.push('')

            if ('SPINNAKER_STAGES_BRANCH' in process.env && process.env.SPINNAKER_STAGES_BRANCH != '') {
              let deployMsg = '${{ env.CONFIG_SHA }} is ready for [deploy via spinnaker](' + executionURL + ') `${{ env.SPINNAKER_STAGES_BRANCH }}` stage'
              if ('SPINNAKER_WEBHOOK_BRANCH' in process.env && process.env.SPINNAKER_WEBHOOK_BRANCH != '') {
                deployMsg += ' or webhook `${{ env.SPINNAKER_WEBHOOK_BRANCH }}` by commenting **/deploy** or adding a `deploy` label on this PR'
              }
              body.push(deployMsg)

              // formatting isn't preserved in github ui unless the newlines are there
              body.push('<details>')
              body.push('<summary>Click to see details for the configuration of the release</summary>')
              body.push('')
              body.push(detailsMsg)
              body.push('')
              body.push('</details>')
            } else {
              body.push(detailsMsg)
            }

            const owner = context.repo.owner,
                repo = context.repo.repo,
                issueNumber = context.issue.number;

            let commentsResponse = await github.rest.issues.listComments({
                owner,
                repo,
                issue_number: issueNumber
            });

            let comments = commentsResponse.data;

            let originalComment = comments.find((comment) => {
                return comment.body.includes(CICD_TOOLKIT_COMMENT_MARKER)
            });

            if (originalComment) {
                github.rest.issues.updateComment({
                    owner,
                    repo,
                    comment_id: originalComment.id,
                    body: body.join("\n")
                });
            } else {
                github.rest.issues.createComment({
                  issue_number: issueNumber,
                  owner: owner,
                  repo: repo,
                  body: body.join("\n")
                })
            }

      - name: find manifests to validate with OPA gatekeeper (k8s)
        if: env.OPA_MANIFEST_VALIDATION_ENABLED == 'true'
        run: |
          has_yml_files="$(find "$DEPLOY_CFG_OUTPUT_DIR/kubernetes/manifests" -name '*.yml' || true)"

          # the opa action fails unless we have manifests directory
          # which we may not in case we have no kubernetes manifests defined
          # for the project
          if [ -n "$has_yml_files" ]; then
            cp -r "$DEPLOY_CFG_OUTPUT_DIR/kubernetes" "$GITHUB_WORKSPACE"
            echo "OPA_SHOULD_VALIDATE=true" >> "$GITHUB_ENV"
          else
            echo "OPA_SHOULD_VALIDATE=false" >> "$GITHUB_ENV"
          fi

      - name: Validate with OPA gatekeeper
        if: env.OPA_MANIFEST_VALIDATION_ENABLED =='true' && env.OPA_SHOULD_VALIDATE == 'true'
        uses: zendesk/ga/opa-gatekeeper@v4
        with:
          pattern: kubernetes/manifests/**/*.yml
